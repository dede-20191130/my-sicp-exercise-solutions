#lang racket
(require compatibility/mlist)

(define (mcaar mpair) (mcar (mcar mpair)))
(define (mcadr mpair) (mcar (mcdr mpair)))
(define (mcddr mpair) (mcdr (mcdr mpair)))
(define (mcaddr mpair) (mcar (mcdr (mcdr mpair))))

(define (entry tree) (mcar tree))
(define (left-owner tree) (mcdr tree))
(define (left-branch tree) (mcar (left-owner tree)))
(define (right-owner tree) (mcddr tree))
(define (right-branch tree) (mcar (right-owner tree)))
(define (make-mtree entry left right)
  (mlist entry left right))

(define (make-records key val left right)
  (if (mpair? val)
      (make-mtree (mcons key val) left right)
      (make-mtree (mlist key val) left right)))

(define (make-terminal key val)
  (make-records key val (mlist) (mlist)))

(define (entry-key tgt-entry) (mcar tgt-entry))
(define (entry-val tgt-entry) (mcadr tgt-entry))
(define (record-key records) (entry-key (entry records)))
(define (record-val records) (entry-val (entry records)))

(define table-records mcdr)

(define (has-only-one? tgt-list)
  (= (length tgt-list) 1))

(define (mhas-only-one? tgt-mlist)
  (= (mlength tgt-mlist) 1))

(define (make-table-of-numeric-tree)
  (define (massoc-for-num-tree key records)
    (cond ((null? records) false)
          ((= key (record-key records)) (entry records))
          ((< key (record-key records))
           (massoc-for-num-tree key (left-branch records)))
          ((> key (record-key records))
           (massoc-for-num-tree key (right-branch records)))))
          
          
  (define (lookup key-list tgt-table)
    (let ((tgt-entry (massoc-for-num-tree (car key-list) (table-records tgt-table))))
      (cond ((not tgt-entry) false)
            ((has-only-one? key-list) (entry-val tgt-entry))
            (else (lookup (cdr key-list) tgt-entry)))))
       
  (define (insert! key-list value tgt-table)
    (define (initialize-record kl value)
      (if (has-only-one? kl)
          (make-terminal (car kl) value)
          (make-terminal (car kl) (initialize-record (cdr kl) value))))
    (define (helper anchor-mpair records)
      (cond ((or
              (null? records)
              (and (not (null? records)) (mhas-only-one? records)))
             (if (null? anchor-mpair)
                 (set-mcdr! tgt-table (initialize-record key-list value))
                 (set-mcar! anchor-mpair (initialize-record key-list value))))
            ((= (car key-list) (record-key records))
             (if (has-only-one? key-list)
                 (set-mcdr! (entry records) (mlist value))
                 (insert! (cdr key-list) value (entry records))))
            ((< (car key-list) (record-key records)) (helper (left-owner records) (left-branch records)))
            ((> (car key-list) (record-key records)) (helper (right-owner records) (right-branch records)))))

    (helper (mlist) (table-records tgt-table))
    'ok)
      
  (let ((local-table (mlist '*table*))) 
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) (λ (key-list) (lookup key-list local-table)))
            ((eq? m 'insert-proc!) (λ (key-list value) (insert! key-list value local-table)))
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table-of-numeric-tree))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(put (list 10) 'foo10)
(put (list 30) 'foo30)
(put (list 20) 'foo20)
(put (list 40) 'foo40)
(get (list 10))
(get (list 20))
(get (list 30))
(get (list 40))
(put (list 30 400) 'bar400)
(put (list 30 300) 'bar300)
(put (list 30 200) 'bar200)
(put (list 30 100) 'bar100)
(get (list 30 100))
(get (list 30 200))
(get (list 30 300))
(get (list 30 400))
(put (list 50 500 5000 50000 500000) '(dog 2000))
(get (list 50 500 5000 50000 500000))
(put (list 50) '(cat 1000))
(get (list 50))